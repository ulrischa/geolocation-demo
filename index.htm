<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Geolocation-Track (Leaflet)</title>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121a24;
      --text: #e8eef7;
      --muted: #a7b3c2;
      --border: #243244;
      --btn: #1f2d3d;
      --btn-hover: #2a3b52;
      --danger: #7d1f2a;
      --danger-hover: #992b39;
      --ok: #204b3a;
      --ok-hover: #2a654f;
      --warn: #a86a10;
      --warn-bg: rgba(168, 106, 16, 0.12);
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
    }

    header h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 650;
    }

    header p {
      margin: 6px 0 0;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    .bar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }

    .group {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,0.02);
      max-width: 100%;
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--btn);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 650;
      font-size: 13px;
      line-height: 1;
      user-select: none;
      white-space: nowrap;
    }
    .btn:hover { background: var(--btn-hover); }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }

    .btn.ok { background: var(--ok); }
    .btn.ok:hover { background: var(--ok-hover); }

    .btn.danger { background: var(--danger); }
    .btn.danger:hover { background: var(--danger-hover); }

    .hint {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.25;
      max-width: 520px;
    }

    .warn {
      border: 1px solid rgba(168, 106, 16, 0.45);
      background: var(--warn-bg);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 12px;
      line-height: 1.3;
      max-width: 880px;
    }

    /* Keep styling on <geolocation> minimal to avoid style blockers. */
    geolocation#geo {
      font-size: 13px;
      min-height: 40px;
      display: inline-flex;
      align-items: center;
    }

    .pulse {
      outline: 2px solid rgba(168, 106, 16, 0.9);
      outline-offset: 2px;
      animation: pulse 1.2s ease-in-out infinite;
      border-radius: 12px;
    }

    @keyframes pulse {
      0% { outline-color: rgba(168, 106, 16, 0.95); }
      50% { outline-color: rgba(168, 106, 16, 0.25); }
      100% { outline-color: rgba(168, 106, 16, 0.95); }
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(140px, 1fr));
      gap: 8px 16px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: rgba(255,255,255,0.02);
    }

    .stat {
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,0.02);
    }

    .stat .k { font-size: 11px; color: var(--muted); }
    .stat .v { margin-top: 4px; font-size: 13px; font-weight: 650; word-break: break-word; }

    .diag {
      grid-column: 1 / -1;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      line-height: 1.35;
      color: var(--muted);
      white-space: pre-wrap;
    }

    #map {
      height: calc(100vh - 56px - 64px - 170px);
      min-height: 340px;
    }

    .footer {
      padding: 10px 16px;
      border-top: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
      background: var(--panel);
    }

    code { color: #cfe3ff; }
  </style>
</head>

<body>
  <header>
    <h1>Live Standortverlauf als Linie (Leaflet)</h1>
    <p>
      Dieses Demo nutzt das neue <code>&lt;geolocation&gt;</code>-Element (Chrome 144+) und zeichnet den Verlauf live als Linie.
      Zusätzlich gibt es einen JS-Fallback über die klassische Geolocation API.
    </p>
  </header>

  <div class="bar">
    <div class="group" title="Tracking">
      <span class="hint">Start:</span>

      <!--
        In unterstützten Browsern rendert <geolocation> selbst ein Browser-UI.
        Die Kinder werden dann nicht gerendert (Fallback nur für nicht unterstützte Browser).
      -->
      <geolocation id="geo" accuracymode="precise" watch autolocate>
        <button id="fallback_start" class="btn ok" type="button">Start (JS)</button>
      </geolocation>

      <!-- Always-visible JS start button for debugging (works unless blocked by secure context / iframe policy). -->
      <button id="start_js" class="btn ok" type="button">Start (JS)</button>

      <button id="pause" class="btn" type="button" disabled>Pause</button>
      <button id="stop" class="btn danger" type="button" disabled>Stopp</button>
    </div>

    <div class="group" title="Optionen">
      <button id="toggle_follow" class="btn" type="button">Follow: an</button>
      <button id="clear" class="btn" type="button" disabled>Linie löschen</button>
    </div>

    <div class="group" title="Status">
      <span id="status" style="color: var(--muted); font-size: 12px;">Bereit</span>
    </div>

    <div class="warn" id="warn_box" hidden></div>
  </div>

  <div class="stats">
    <div class="stat"><div class="k">Punkte</div><div class="v" id="s_points">0</div></div>
    <div class="stat"><div class="k">Distanz (ca.)</div><div class="v" id="s_dist">0 m</div></div>
    <div class="stat"><div class="k">Letzter Fix</div><div class="v" id="s_time">–</div></div>
    <div class="stat"><div class="k">Genauigkeit</div><div class="v" id="s_acc">–</div></div>

    <div class="stat diag">
      <div class="k">Diagnostik</div>
      <div class="v" id="diag">–</div>
    </div>
  </div>

  <div id="map"></div>

  <div class="footer">
    Hinweis: Geolocation benötigt einen <code>secure context</code> (HTTPS oder <code>http://localhost</code>). In iFrames kann Geolocation per Permissions Policy blockiert sein.
  </div>

  <script type="module">
    // --- Optional polyfill (does nothing if native <geolocation> exists) ---
    try {
      if (!('HTMLGeolocationElement' in window)) {
        await import('https://unpkg.com/geolocation-element-polyfill/index.js');
      }
    } catch (err) {
      console.warn('Geolocation element polyfill failed to load:', err);
    }

    // --- Leaflet map setup ---
    const map = L.map('map', {
      zoomControl: true,
      attributionControl: true,
    }).setView([48.137154, 11.576124], 12); // default: München

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors',
    }).addTo(map);

    const polyline = L.polyline([], { weight: 4 }).addTo(map);
    let marker = null;

    // --- UI refs ---
    const geo_el = document.getElementById('geo');
    const fallback_start_btn = document.getElementById('fallback_start');
    const start_js_btn = document.getElementById('start_js');
    const pause_btn = document.getElementById('pause');
    const stop_btn = document.getElementById('stop');
    const toggle_follow_btn = document.getElementById('toggle_follow');
    const clear_btn = document.getElementById('clear');
    const status_el = document.getElementById('status');
    const warn_box = document.getElementById('warn_box');

    const s_points = document.getElementById('s_points');
    const s_dist = document.getElementById('s_dist');
    const s_time = document.getElementById('s_time');
    const s_acc = document.getElementById('s_acc');
    const diag_el = document.getElementById('diag');

    // --- State ---
    let is_tracking = false;
    let is_paused = false;
    let follow = true;

    /** @type {Array<{lat:number,lng:number,t:number,acc?:number}>} */
    let points = [];
    let approx_distance_m = 0;

    // JS fallback watcher id
    let watch_id = null;

    // Permissions API state (if available)
    let permissions_api_state = 'n/a';

    // --- Helpers ---
    function set_status(msg) {
      status_el.textContent = msg;
    }

    function show_warn(lines) {
      if (!lines || lines.length === 0) {
        warn_box.hidden = true;
        warn_box.textContent = '';
        return;
      }
      warn_box.hidden = false;
      warn_box.textContent = lines.join('
');
    }

    function fmt_time(ts) {
      const d = new Date(ts);
      const pad2 = (n) => String(n).padStart(2, '0');
      return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
    }

    function haversine_m(a, b) {
      const R = 6371000;
      const to_rad = (deg) => (deg * Math.PI) / 180;
      const d_lat = to_rad(b.lat - a.lat);
      const d_lng = to_rad(b.lng - a.lng);
      const lat1 = to_rad(a.lat);
      const lat2 = to_rad(b.lat);

      const h =
        Math.sin(d_lat / 2) ** 2 +
        Math.cos(lat1) * Math.cos(lat2) * Math.sin(d_lng / 2) ** 2;

      return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
    }

    function update_stats() {
      s_points.textContent = String(points.length);
      s_dist.textContent = `${Math.round(approx_distance_m)} m`;

      const last = points.at(-1);
      if (!last) {
        s_time.textContent = '–';
        s_acc.textContent = '–';
        return;
      }

      s_time.textContent = fmt_time(last.t);
      s_acc.textContent = typeof last.acc === 'number' ? `${Math.round(last.acc)} m` : '–';
    }

    function reset_track() {
      points = [];
      approx_distance_m = 0;
      polyline.setLatLngs([]);
      if (marker) {
        map.removeLayer(marker);
        marker = null;
      }
      update_stats();
    }

    function add_point(lat, lng, acc) {
      const now = Date.now();
      const next = { lat, lng, t: now, acc };

      const last = points.at(-1);
      if (last) {
        const d = haversine_m(last, next);
        // Filter tiny noise steps; still accept if time gap is large.
        const time_gap = now - last.t;
        if (d < 2 && time_gap < 5000) return;
        approx_distance_m += d;
      }

      points.push(next);
      polyline.addLatLng([lat, lng]);

      if (!marker) {
        marker = L.marker([lat, lng]).addTo(map);
        map.setView([lat, lng], 18);
      } else {
        marker.setLatLng([lat, lng]);
        if (follow) map.panTo([lat, lng], { animate: true });
      }

      update_stats();
      clear_btn.disabled = points.length === 0;
    }

    function set_controls_state() {
      pause_btn.disabled = !is_tracking;
      stop_btn.disabled = !is_tracking;
      clear_btn.disabled = points.length === 0;

      pause_btn.textContent = is_paused ? 'Weiter' : 'Pause';
    }

    async function refresh_permissions_api_state() {
      permissions_api_state = 'n/a';
      if (!navigator.permissions?.query) return;
      try {
        // @ts-ignore
        const res = await navigator.permissions.query({ name: 'geolocation' });
        permissions_api_state = res.state;
        res.onchange = () => { render_diag(); };
      } catch {
        permissions_api_state = 'error';
      }
    }

    function render_diag() {
      const supports_geo_el = ('HTMLGeolocationElement' in window) ? 'yes' : 'no';
      const proto = location.protocol;
      const secure = window.isSecureContext ? 'yes' : 'no';
      const iframe = (window.top !== window.self) ? 'yes' : 'no';
      const nav_geo = ('geolocation' in navigator) ? 'yes' : 'no';

      const lines = [];
      lines.push(`protocol: ${proto}`);
      lines.push(`secure_context: ${secure}`);
      lines.push(`in_iframe: ${iframe}`);
      lines.push(`navigator.geolocation: ${nav_geo}`);
      lines.push(`permissions_api.geolocation: ${permissions_api_state}`);
      lines.push(`html_geolocation_element: ${supports_geo_el}`);

      if ('HTMLGeolocationElement' in window) {
        const is_valid = (typeof geo_el.isValid === 'boolean') ? String(geo_el.isValid) : 'n/a';
        const invalid_reason = (typeof geo_el.invalidReason === 'string') ? (geo_el.invalidReason || '(none)') : 'n/a';
        const initial = (typeof geo_el.initialPermissionStatus === 'string') ? geo_el.initialPermissionStatus : 'n/a';
        const current = (typeof geo_el.permissionStatus === 'string') ? geo_el.permissionStatus : 'n/a';

        lines.push(`geo.isValid: ${is_valid}`);
        lines.push(`geo.invalidReason: ${invalid_reason}`);
        lines.push(`geo.initialPermissionStatus: ${initial}`);
        lines.push(`geo.permissionStatus: ${current}`);
      }

      diag_el.textContent = lines.join('
');

      const warns = [];
      if (secure === 'no') {
        warns.push('Kein secure context: nutze https oder http://localhost.');
      }
      if (proto === 'file:') {
        warns.push('file:// erkannt: starte über localhost oder https, sonst kommt oft keine Permission.');
      }
      if (iframe === 'yes') {
        warns.push('In einem iFrame: Geolocation kann per Permissions Policy blockiert sein. In diesem Fall erscheint keine Permission-Abfrage.');
      }
      show_warn(warns);
    }

    // --- <geolocation> event handlers ---
    function handle_geo_element_location() {
      if (!is_tracking || is_paused) return;

      if (geo_el?.position?.coords) {
        const { latitude, longitude, accuracy } = geo_el.position.coords;
        add_point(latitude, longitude, accuracy);
        set_status(`Tracking aktiv (${points.length} Punkte)`);
      } else if (geo_el?.error) {
        set_status(`Fehler: ${geo_el.error.message || 'Unbekannt'}`);
      }

      render_diag();
    }

    function handle_prompt_action() {
      // Fires when user chose allow/deny in the dialog.
      render_diag();
      if (typeof geo_el.permissionStatus === 'string') {
        if (geo_el.permissionStatus === 'denied') {
          set_status('Permission ist abgelehnt (Site-Einstellung prüfen).');
        } else if (geo_el.permissionStatus === 'granted') {
          set_status('Permission erteilt.');
        }
      }
    }

    function handle_prompt_dismiss() {
      render_diag();
      set_status('Permission-Dialog geschlossen. Tippe erneut auf das Element.');
    }

    // --- JS Geolocation API fallback ---
    function start_js_watch() {
      if (!('geolocation' in navigator)) {
        set_status('Geolocation nicht verfügbar (navigator.geolocation fehlt).');
        return;
      }

      if (watch_id !== null) {
        navigator.geolocation.clearWatch(watch_id);
        watch_id = null;
      }

      watch_id = navigator.geolocation.watchPosition(
        (pos) => {
          if (!is_tracking || is_paused) return;
          add_point(pos.coords.latitude, pos.coords.longitude, pos.coords.accuracy);
          set_status(`Tracking aktiv (${points.length} Punkte)`);
        },
        (err) => {
          set_status(`Fehler: ${err.message || 'Unbekannt'}`);
          render_diag();
        },
        { enableHighAccuracy: true, maximumAge: 0, timeout: 15000 }
      );
    }

    function stop_js_watch() {
      if (watch_id !== null && 'geolocation' in navigator) {
        navigator.geolocation.clearWatch(watch_id);
        watch_id = null;
      }
    }

    // --- Start/Pause/Stop logic ---
    function start_tracking({ prefer_js } = { prefer_js: false }) {
      reset_track();
      is_tracking = true;
      is_paused = false;
      set_controls_state();

      if (prefer_js) {
        set_status('Starte über JS-Geolocation… (Permission bestätigen)');
        start_js_watch();
        return;
      }

      if ('HTMLGeolocationElement' in window) {
        // Permission dialog is triggered by user action on the browser-rendered control.
        geo_el.classList.add('pulse');
        set_status('Zum Start auf das <geolocation>-Element klicken (Browser-UI). Alternativ: Start (JS).');
        geo_el.setAttribute('watch', '');
        geo_el.setAttribute('autolocate', '');
        window.setTimeout(() => geo_el.classList.remove('pulse'), 3500);
      } else {
        set_status('Starte über JS-Geolocation… (Permission bestätigen)');
        start_js_watch();
      }
    }

    function pause_tracking() {
      if (!is_tracking) return;
      is_paused = !is_paused;

      if (is_paused) {
        set_status('Pausiert');
        // Reduce background work
        stop_js_watch();
        try { geo_el.removeAttribute('watch'); } catch { /* ignore */ }
      } else {
        set_status('Tracking aktiv');
        // Resume with the most reliable path: JS watcher (does not prevent <geolocation> updates)
        start_js_watch();
        try { geo_el.setAttribute('watch', ''); } catch { /* ignore */ }
      }

      set_controls_state();
      render_diag();
    }

    function stop_tracking() {
      if (!is_tracking) return;

      is_tracking = false;
      is_paused = false;

      stop_js_watch();
      try { geo_el.removeAttribute('watch'); } catch { /* ignore */ }

      set_status('Gestoppt');
      set_controls_state();
      render_diag();
    }

    // --- Wire up events ---
    geo_el.addEventListener('location', handle_geo_element_location);
    geo_el.addEventListener('promptaction', handle_prompt_action);
    geo_el.addEventListener('promptdismiss', handle_prompt_dismiss);
    geo_el.addEventListener('validationstatuschange', render_diag);

    // In supporting browsers, user must click the <geolocation> control.
    geo_el.addEventListener('click', () => {
      if (!is_tracking) start_tracking();
    });

    // Fallback button inside <geolocation> is only visible when <geolocation> is not supported.
    if (fallback_start_btn) {
      fallback_start_btn.addEventListener('click', (e) => {
        e.preventDefault();
        start_tracking({ prefer_js: true });
      });
    }

    // Always-visible JS start button for debugging.
    start_js_btn.addEventListener('click', () => start_tracking({ prefer_js: true }));

    pause_btn.addEventListener('click', pause_tracking);
    stop_btn.addEventListener('click', stop_tracking);

    clear_btn.addEventListener('click', () => {
      reset_track();
      set_status(is_tracking ? 'Tracking aktiv (Linie gelöscht)' : 'Linie gelöscht');
      set_controls_state();
    });

    toggle_follow_btn.addEventListener('click', () => {
      follow = !follow;
      toggle_follow_btn.textContent = `Follow: ${follow ? 'an' : 'aus'}`;
      set_status(follow ? 'Follow aktiviert' : 'Follow deaktiviert');
    });

    // Init
    set_controls_state();
    await refresh_permissions_api_state();
    render_diag();

    // Periodic refresh
    window.setInterval(async () => {
      await refresh_permissions_api_state();
      render_diag();
    }, 4000);
  </script>
</body>
</html>
