<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Geolocation Track (Leaflet)</title>

  <!-- Leaflet (no SRI; reduces breakage in sandbox/CSP environments) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root {
      --bg: #0b0f14;
      --panel: #121a24;
      --text: #e8eef7;
      --muted: #a7b3c2;
      --border: #243244;
      --btn: #1f2d3d;
      --btn-hover: #2a3b52;
      --danger: #7d1f2a;
      --danger-hover: #992b39;
      --ok: #204b3a;
      --ok-hover: #2a654f;
      --warn-bg: rgba(168,106,16,0.12);
      --err-bg: rgba(181,58,74,0.12);
      --ok-bg: rgba(42,101,79,0.12);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0));
    }

    header h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 650;
    }

    header p {
      margin: 6px 0 0;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    .bar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }

    .group {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,0.02);
      max-width: 100%;
    }

    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--btn);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 650;
      font-size: 13px;
      line-height: 1;
      user-select: none;
      white-space: nowrap;
    }

    .btn:hover { background: var(--btn-hover); }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }

    .btn.ok { background: var(--ok); }
    .btn.ok:hover { background: var(--ok-hover); }

    .btn.danger { background: var(--danger); }
    .btn.danger:hover { background: var(--danger-hover); }

    .hint {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.25;
      max-width: 520px;
    }

    .panel {
      border: 1px solid rgba(168,106,16,0.45);
      background: var(--warn-bg);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 12px;
      line-height: 1.3;
      max-width: 980px;
      white-space: pre-wrap;
    }

    .panel.error {
      border-color: rgba(181,58,74,0.55);
      background: var(--err-bg);
    }

    .panel.ok {
      border-color: rgba(42,101,79,0.55);
      background: var(--ok-bg);
    }

    /* Keep styling on <geolocation> minimal. */
    geolocation#geo {
      font-size: 13px;
      min-height: 40px;
      display: inline-flex;
      align-items: center;
    }

    .pulse {
      outline: 2px solid rgba(168,106,16,0.9);
      outline-offset: 2px;
      animation: pulse 1.2s ease-in-out infinite;
      border-radius: 12px;
    }

    @keyframes pulse {
      0% { outline-color: rgba(168,106,16,0.95); }
      50% { outline-color: rgba(168,106,16,0.25); }
      100% { outline-color: rgba(168,106,16,0.95); }
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, minmax(140px, 1fr));
      gap: 8px 16px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: rgba(255,255,255,0.02);
    }

    .stat {
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255,255,255,0.02);
    }

    .stat .k { font-size: 11px; color: var(--muted); }
    .stat .v { margin-top: 4px; font-size: 13px; font-weight: 650; word-break: break-word; }

    .diag {
      grid-column: 1 / -1;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      line-height: 1.35;
      color: var(--muted);
      white-space: pre-wrap;
    }

    #map {
      height: 60vh;
      min-height: 340px;
      border-top: 1px solid var(--border);
    }

    .footer {
      padding: 10px 16px;
      border-top: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
      background: var(--panel);
    }

    code { color: #cfe3ff; }
  </style>
</head>
<body>
  <header>
    <h1>Live Standortverlauf als Linie (Leaflet)</h1>
    <p>
      Zeichnet deinen Standortverlauf live als Linie. Buttons: Start, Pause, Stopp.
      Start (JS) nutzt navigator.geolocation als Fallback.
    </p>
  </header>

  <div class="bar">
    <div class="group" title="Tracking">
      <span class="hint">Start:</span>

      <!-- In Chrome 144+ should render its own control. -->
      <geolocation id="geo" accuracymode="precise" watch autolocate>
        <!-- Fallback content (visible when element not supported) -->
        <button id="fallback_start" class="btn ok" type="button">Start (JS)</button>
      </geolocation>

      <button id="start_js" class="btn ok" type="button">Start (JS)</button>
      <button id="pause" class="btn" type="button" disabled>Pause</button>
      <button id="stop" class="btn danger" type="button" disabled>Stopp</button>
    </div>

    <div class="group" title="Optionen">
      <button id="toggle_follow" class="btn" type="button">Follow: an</button>
      <button id="clear" class="btn" type="button" disabled>Linie loeschen</button>
    </div>

    <div class="group" title="Status">
      <span id="status" style="color: var(--muted); font-size: 12px;">Bereit</span>
    </div>

    <div class="panel" id="warn_box" hidden></div>
    <div class="panel error" id="error_box" hidden></div>
    <div class="panel ok" id="test_box" hidden></div>
  </div>

  <div class="stats">
    <div class="stat"><div class="k">Punkte</div><div class="v" id="s_points">0</div></div>
    <div class="stat"><div class="k">Distanz (ca.)</div><div class="v" id="s_dist">0 m</div></div>
    <div class="stat"><div class="k">Letzter Fix</div><div class="v" id="s_time">-</div></div>
    <div class="stat"><div class="k">Genauigkeit</div><div class="v" id="s_acc">-</div></div>

    <div class="stat diag">
      <div class="k">Diagnostik</div>
      <div class="v" id="diag">(initializing...)</div>
    </div>
  </div>

  <div id="map"></div>

  <div class="footer">
    Hinweis: Geolocation benoetigt HTTPS oder http://localhost. In iFrames kann Geolocation blockiert sein.
  </div>

  <script>
  (function () {
    'use strict';

    // If you still get "Invalid or unexpected token", it is almost certainly caused by
    // a hidden non-printable character injected by the environment/editor. This file uses ASCII only.

    var error_box = document.getElementById('error_box');
    var warn_box = document.getElementById('warn_box');
    var test_box = document.getElementById('test_box');

    function show_error(msg) {
      if (!error_box) return;
      error_box.hidden = false;
      error_box.textContent = String(msg);
    }

    function hide_error() {
      if (!error_box) return;
      error_box.hidden = true;
      error_box.textContent = '';
    }

    window.addEventListener('error', function (e) {
      show_error('JS error: ' + e.message + '\n' + (e.filename || '') + ':' + (e.lineno || ''));
    });

    window.addEventListener('unhandledrejection', function (e) {
      var r = (e && e.reason) ? (e.reason.message || String(e.reason)) : 'unknown';
      show_error('Promise rejection: ' + r);
    });

    var geo_el = document.getElementById('geo');
    var fallback_start_btn = document.getElementById('fallback_start');
    var start_js_btn = document.getElementById('start_js');
    var pause_btn = document.getElementById('pause');
    var stop_btn = document.getElementById('stop');
    var toggle_follow_btn = document.getElementById('toggle_follow');
    var clear_btn = document.getElementById('clear');
    var status_el = document.getElementById('status');

    var s_points = document.getElementById('s_points');
    var s_dist = document.getElementById('s_dist');
    var s_time = document.getElementById('s_time');
    var s_acc = document.getElementById('s_acc');
    var diag_el = document.getElementById('diag');

    function set_status(msg) {
      if (status_el) status_el.textContent = msg;
    }

    function show_warn(lines) {
      if (!warn_box) return;
      if (!lines || lines.length === 0) {
        warn_box.hidden = true;
        warn_box.textContent = '';
        return;
      }
      warn_box.hidden = false;
      warn_box.textContent = lines.join('\n');
    }

    function show_tests(lines) {
      if (!test_box) return;
      if (!lines || lines.length === 0) {
        test_box.hidden = true;
        test_box.textContent = '';
        return;
      }
      test_box.hidden = false;
      test_box.textContent = lines.join('\n');
    }

    var is_tracking = false;
    var is_paused = false;
    var follow = true;

    var points = [];
    var approx_distance_m = 0;

    var watch_id = null;
    var permissions_api_state = 'n/a';

    function pad2(n) {
      var s = String(n);
      return (s.length < 2) ? ('0' + s) : s;
    }

    function fmt_time(ts) {
      var d = new Date(ts);
      return pad2(d.getHours()) + ':' + pad2(d.getMinutes()) + ':' + pad2(d.getSeconds());
    }

    function haversine_m(a, b) {
      var R = 6371000;
      function to_rad(deg) { return (deg * Math.PI) / 180; }
      var d_lat = to_rad(b.lat - a.lat);
      var d_lng = to_rad(b.lng - a.lng);
      var lat1 = to_rad(a.lat);
      var lat2 = to_rad(b.lat);

      var h =
        Math.sin(d_lat / 2) * Math.sin(d_lat / 2) +
        Math.cos(lat1) * Math.cos(lat2) * Math.sin(d_lng / 2) * Math.sin(d_lng / 2);

      return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
    }

    function last_point() {
      return points.length ? points[points.length - 1] : null;
    }

    function update_stats() {
      if (s_points) s_points.textContent = String(points.length);
      if (s_dist) s_dist.textContent = String(Math.round(approx_distance_m)) + ' m';

      var last = last_point();
      if (!last) {
        if (s_time) s_time.textContent = '-';
        if (s_acc) s_acc.textContent = '-';
        return;
      }

      if (s_time) s_time.textContent = fmt_time(last.t);
      if (s_acc) s_acc.textContent = (typeof last.acc === 'number') ? (String(Math.round(last.acc)) + ' m') : '-';
    }

    // Leaflet state
    var map = null;
    var polyline = null;
    var marker = null;

    function init_map() {
      if (!(window.L && typeof window.L.map === 'function')) {
        show_error('Leaflet konnte nicht geladen werden. (CSP/Netzwerk blockiert?)');
        return;
      }

      map = window.L.map('map', { zoomControl: true, attributionControl: true }).setView([48.137154, 11.576124], 12);

      window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      polyline = window.L.polyline([], { weight: 4 }).addTo(map);

      setTimeout(function () { if (map && map.invalidateSize) map.invalidateSize(); }, 0);
      setTimeout(function () { if (map && map.invalidateSize) map.invalidateSize(); }, 250);
    }

    function reset_track() {
      points = [];
      approx_distance_m = 0;
      if (polyline) polyline.setLatLngs([]);
      if (marker) { marker.remove(); marker = null; }
      update_stats();
    }

    function add_point(lat, lng, acc) {
      if (!map || !polyline) return;

      var now = Date.now();
      var next = { lat: lat, lng: lng, t: now, acc: acc };

      var last = last_point();
      if (last) {
        var d = haversine_m(last, next);
        var time_gap = now - last.t;
        if (d < 2 && time_gap < 5000) return;
        approx_distance_m += d;
      }

      points.push(next);
      polyline.addLatLng([lat, lng]);

      if (!marker) {
        marker = window.L.marker([lat, lng]).addTo(map);
        map.setView([lat, lng], 18);
      } else {
        marker.setLatLng([lat, lng]);
        if (follow) map.panTo([lat, lng], { animate: true });
      }

      update_stats();
      if (clear_btn) clear_btn.disabled = (points.length === 0);
    }

    function set_controls_state() {
      if (pause_btn) pause_btn.disabled = !is_tracking;
      if (stop_btn) stop_btn.disabled = !is_tracking;
      if (clear_btn) clear_btn.disabled = (points.length === 0);
      if (pause_btn) pause_btn.textContent = is_paused ? 'Weiter' : 'Pause';
    }

    function refresh_permissions_api_state() {
      permissions_api_state = 'n/a';
      if (!(navigator.permissions && navigator.permissions.query)) return Promise.resolve();

      return navigator.permissions.query({ name: 'geolocation' }).then(
        function (res) {
          permissions_api_state = res.state;
          res.onchange = function () { render_diag(); };
        },
        function () { permissions_api_state = 'error'; }
      );
    }

    function render_diag() {
      if (!diag_el) return;

      var supports_geo_el = ('HTMLGeolocationElement' in window) ? 'yes' : 'no';
      var proto = location.protocol;
      var secure = window.isSecureContext ? 'yes' : 'no';
      var iframe = (window.top !== window.self) ? 'yes' : 'no';
      var nav_geo = ('geolocation' in navigator) ? 'yes' : 'no';
      var leaflet = (window.L && typeof window.L.map === 'function') ? 'yes' : 'no';

      var lines = [];
      lines.push('protocol: ' + proto);
      lines.push('secure_context: ' + secure);
      lines.push('in_iframe: ' + iframe);
      lines.push('navigator.geolocation: ' + nav_geo);
      lines.push('permissions_api.geolocation: ' + permissions_api_state);
      lines.push('html_geolocation_element: ' + supports_geo_el);
      lines.push('leaflet_loaded: ' + leaflet);

      if ('HTMLGeolocationElement' in window && geo_el) {
        var is_valid = (typeof geo_el.isValid === 'boolean') ? String(geo_el.isValid) : 'n/a';
        var invalid_reason = (typeof geo_el.invalidReason === 'string') ? (geo_el.invalidReason || '(none)') : 'n/a';
        var initial = (typeof geo_el.initialPermissionStatus === 'string') ? geo_el.initialPermissionStatus : 'n/a';
        var current = (typeof geo_el.permissionStatus === 'string') ? geo_el.permissionStatus : 'n/a';

        lines.push('geo.isValid: ' + is_valid);
        lines.push('geo.invalidReason: ' + invalid_reason);
        lines.push('geo.initialPermissionStatus: ' + initial);
        lines.push('geo.permissionStatus: ' + current);
      }

      diag_el.textContent = lines.join('\n');

      var warns = [];
      if (secure === 'no') warns.push('Kein secure context: nutze https oder http://localhost.');
      if (proto === 'file:') warns.push('file:// erkannt: starte ueber localhost oder https.');
      if (iframe === 'yes') warns.push('In einem iFrame: Geolocation kann blockiert sein.');
      if (leaflet === 'no') warns.push('Leaflet ist nicht geladen (CSP/Netzwerk blockiert).');
      show_warn(warns);
    }

    function start_js_watch() {
      if (!('geolocation' in navigator)) {
        set_status('Geolocation nicht verfuegbar (navigator.geolocation fehlt).');
        return;
      }

      if (watch_id !== null) {
        navigator.geolocation.clearWatch(watch_id);
        watch_id = null;
      }

      watch_id = navigator.geolocation.watchPosition(
        function (pos) {
          if (!is_tracking || is_paused) return;
          add_point(pos.coords.latitude, pos.coords.longitude, pos.coords.accuracy);
          set_status('Tracking aktiv (' + points.length + ' Punkte)');
        },
        function (err) {
          set_status('Fehler: ' + (err.message || 'Unbekannt'));
          render_diag();
        },
        { enableHighAccuracy: true, maximumAge: 0, timeout: 15000 }
      );
    }

    function stop_js_watch() {
      if (watch_id !== null && ('geolocation' in navigator)) {
        navigator.geolocation.clearWatch(watch_id);
        watch_id = null;
      }
    }

    function handle_geo_element_location() {
      if (!is_tracking || is_paused) return;
      if (geo_el && geo_el.position && geo_el.position.coords) {
        var c = geo_el.position.coords;
        add_point(c.latitude, c.longitude, c.accuracy);
        set_status('Tracking aktiv (' + points.length + ' Punkte)');
      }
      render_diag();
    }

    function start_tracking(prefer_js) {
      reset_track();
      is_tracking = true;
      is_paused = false;
      set_controls_state();

      if (prefer_js) {
        set_status('Starte ueber JS-Geolocation (Permission bestaetigen)');
        start_js_watch();
        return;
      }

      if ('HTMLGeolocationElement' in window && geo_el) {
        geo_el.classList.add('pulse');
        set_status('Zum Start auf <geolocation> klicken (Browser-UI). Alternativ: Start (JS).');
        try { geo_el.setAttribute('watch', ''); } catch (e) {}
        try { geo_el.setAttribute('autolocate', ''); } catch (e2) {}
        setTimeout(function () { geo_el.classList.remove('pulse'); }, 3500);
      } else {
        set_status('Starte ueber JS-Geolocation (Permission bestaetigen)');
        start_js_watch();
      }
    }

    function pause_tracking() {
      if (!is_tracking) return;
      is_paused = !is_paused;

      if (is_paused) {
        set_status('Pausiert');
        stop_js_watch();
        try { if (geo_el) geo_el.removeAttribute('watch'); } catch (e) {}
      } else {
        set_status('Tracking aktiv');
        start_js_watch();
        try { if (geo_el) geo_el.setAttribute('watch', ''); } catch (e2) {}
      }

      set_controls_state();
      render_diag();
    }

    function stop_tracking() {
      if (!is_tracking) return;
      is_tracking = false;
      is_paused = false;

      stop_js_watch();
      try { if (geo_el) geo_el.removeAttribute('watch'); } catch (e) {}

      set_status('Gestoppt');
      set_controls_state();
      render_diag();
    }

    // Tests: keep existing test cases, add more.
    function run_tests() {
      var results = [];

      // 1) newline join works
      var joined = ['a', 'b'].join('\n');
      if (joined === 'a\nb') results.push('PASS: newline join works');
      else results.push('FAIL: newline join works');

      // 2) Leaflet loaded
      var leaflet_ok = (window.L && typeof window.L.map === 'function');
      results.push((leaflet_ok ? 'PASS' : 'FAIL') + ': Leaflet loaded');

      // 3) map container height
      var map_el = document.getElementById('map');
      var h = map_el ? map_el.getBoundingClientRect().height : 0;
      results.push(((h >= 200) ? 'PASS' : 'FAIL') + ': map container height (' + Math.round(h) + 'px)');

      // 4) navigator.geolocation present
      var geo_api_ok = ('geolocation' in navigator);
      results.push((geo_api_ok ? 'PASS' : 'FAIL') + ': navigator.geolocation present');

      // 5) secure context
      var secure_ok = !!window.isSecureContext;
      results.push((secure_ok ? 'PASS' : 'FAIL') + ': secure context');

      // 6) DOM elements exist
      results.push((geo_el ? 'PASS' : 'FAIL') + ': geolocation element exists');
      results.push((status_el ? 'PASS' : 'FAIL') + ': status element exists');

      show_tests(results);
    }

    // Wire up
    if (geo_el) {
      geo_el.addEventListener('location', handle_geo_element_location);
      geo_el.addEventListener('promptaction', function () { render_diag(); });
      geo_el.addEventListener('promptdismiss', function () {
        render_diag();
        set_status('Permission-Dialog geschlossen. Tippe erneut auf das Element.');
      });
      geo_el.addEventListener('validationstatuschange', function () { render_diag(); });
      geo_el.addEventListener('click', function () { if (!is_tracking) start_tracking(false); });
    }

    if (fallback_start_btn) {
      fallback_start_btn.addEventListener('click', function (e) {
        e.preventDefault();
        start_tracking(true);
      });
    }

    if (start_js_btn) start_js_btn.addEventListener('click', function () { start_tracking(true); });
    if (pause_btn) pause_btn.addEventListener('click', pause_tracking);
    if (stop_btn) stop_btn.addEventListener('click', stop_tracking);

    if (clear_btn) {
      clear_btn.addEventListener('click', function () {
        reset_track();
        set_status(is_tracking ? 'Tracking aktiv (Linie geloescht)' : 'Linie geloescht');
        set_controls_state();
      });
    }

    if (toggle_follow_btn) {
      toggle_follow_btn.addEventListener('click', function () {
        follow = !follow;
        toggle_follow_btn.textContent = 'Follow: ' + (follow ? 'an' : 'aus');
        set_status(follow ? 'Follow aktiviert' : 'Follow deaktiviert');
      });
    }

    // Init
    try {
      hide_error();
      init_map();
      refresh_permissions_api_state().then(function () {
        render_diag();
        set_controls_state();
        run_tests();
        setInterval(function () {
          refresh_permissions_api_state().then(render_diag);
        }, 4000);
      });
    } catch (e) {
      show_error((e && e.message) ? e.message : e);
    }
  })();
  </script>
</body>
</html>
<!-- EOF -->
